<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[word-press-quick-start]]></title>
    <url>%2F2018%2F12%2F11%2Fword-press-quick-start%2F</url>
    <content type="text"><![CDATA[Wordpress 安装和使用我们可以在本机安装 wordpress，从而能在本地建站，折腾并调试。本文将详细介绍如何在Mac下安装wordpress。[toc] 首先安装XAMPP下载xampp下载地址双击安装在终端中使用下面的命令启动 XAMPP：1234567891011sudo /Applications/XAMPP/xamppfiles/xampp start// 终端提示输入密码Password:// 密码输入后回车Starting XAMPP for Mac OS X 5.6.21-0...XAMPP: Starting Apache...already running.XAMPP: Starting MySQL...ok.XAMPP: Starting ProFTPD...ok.// 启动成功 安装成功之后在浏览器中输入 http://localhost 为wordpress安装数据库wordpress自身是不带数据库的，需要我们在XAMPP中创建数据库。在浏览器中输入：http://localhost/phpmyadmin/，进入数据库管理界面。输入数据库名：wordpress_test（可自定义），排序规则选择：utf8_general_ci 下载wordpress下载wordpress(最新版本)，然后解压 wordpress至：/Applications/XAMPP/xamppfiles/htdocs/ 下 修改配置文件拷贝 /Applications/XAMPP/xamppfiles/htdocs/wordpress/wp-config-sample.php的内容至 新建的文件/Applications/XAMPP/xamppfiles/htdocs/wordpress/wp-config.php，然后用文本编辑器打开，进行如下三处修改： 修改数据库名称database_name_here为你的数据库名 修改数据库用户名username_here为root 修改数据库密码为空，就是把password_here删除 登陆WordPress在浏览器中输入：http://localhost/wordpress/，你应该可以看到如下设置页面在这个设置页面设置站点标题，登陆用户名，密码即可。然后就可以看到如下页面恭喜，wordpress已经成功安装了 更换主题及安装失败问题有两种方法： 下载主题包，解压，上传到服务器wp-content/themes目录下，然后进入管理后台，启用新主题即可。 直接在后台主题管理处，根据需求搜索主题，然后点击安装，即可实现在线安装。 注意:在线安装主题、插件有可能会出现失败情况，错误提示是没有权限,解决办法如下：将wp-content 文件夹的权限改为755，将wp-content/theme和wp-content/plugin 文件夹的权限改为777。如果还是提示同样的错误无法安装主题和插件的话，那就只能将 wp-content 文件夹的权限改为777（下策）。 图片无法上传及大小限制问题WordPress管理后台支持图片上传，但是第一次使用时候报错（阿里云下PHP+Apache+nginx环境）, 无法上传问题解决： uploads文件夹不存在———新建该文件夹 数据库 wp_options 表的uploads_path 键的值不为wp-contents/uploads——-输入该值 wp-content 权限改为755 uploads 权限改为777 大小限制2M问题—–解决: 主机的 etc/php5/fpm 目录下php.ini文件修改以下字段的值如下 123upload_max_filesize = 32M post_max_size = 32M max_execution_time = 300 cd 到 /etc/nigix/目录下找到 nginx 的config 文件 修改以下字段的值如下 12345http &#123;#... client_max_body_size 32M;#...&#125; 然后重启php-fpm 和nginx 12service nginx restartservice php5-fpm restart 参考链接]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas-pie]]></title>
    <url>%2F2018%2F12%2F10%2Fcanvas-pie%2F</url>
    <content type="text"><![CDATA[在Canvas上将数据画成饼图将这个功能封装成为一个pie对象，只需要将参数对象传递给pie.init(config)函数，就能初始化canvas，然后调用pie.render()函数，饼图就画好啦。 使用方法： 引入pie.js文件最开始需要在你的代码前面引入pie.js文件，你可以放在head标签里面，也可以放在body底部其他script标签的前面。 获取canvas元素 1var canvas = document.getElementById("cas"); 设置参数准备好数据、图例和颜色（内置了9个颜色，数据数量小于9的话，不传颜色参数也可以啦~） 1234567891011var data = [10,20,50,100,30,40,70,22];var legend=["C++","Ruby","Java","JS","Python","R","C","D"];var colors=["#CCFFFF",'#99CC66','#CCCCFF','#0099CC',"#FF6600",'#996699','#FFFF00',"#FF6666"]var config=&#123; canvas:canvas, series:data, title:"Coding language", legend:legend, tip:&#123;enable:true&#125;, colors:colors&#125; 使用pie的初始化函数载入数据, 使用pie.render()画图 1234//调用pie的初始化函数pie.init(config);//绘制饼图pie.render(); 附录pie.js源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194// 绘制饼图的对象var pie=&#123; canvas:null, series:[], legend:[], title:"Pie", width:0, height:0, tip:&#123; enable:false, canvas : null, ctx: null, index: -1 &#125;, radius:0, center:&#123;&#125;, colors:["#FF6666","#CCFFFF",'#99CC66','#CCCCFF','#0099CC',"#FF6600",'#996699','#FFFF00','#FFFF00'], //初始化参数的函数 init:function(config)&#123; this.canvas=config.canvas; this.series=config.series; this.legend=config.legend; this.title=config.title; this.width=this.canvas.width; this.height=this.canvas.height; if(config.tip)&#123; this.tip.enable=config.tip.enable; &#125;; this.colors=config.colors||this.colors; &#125;, //获取 鼠标的绝对坐标(即使有滚动的情况下) getMousePos:function(event) &#123; var e = event || window.event; var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft; var scrollY = document.documentElement.scrollTop || document.body.scrollTop; var x = e.pageX || e.clientX + scrollX; var y = e.pageY || e.clientY + scrollY; return &#123; 'x': x, 'y': y &#125;; &#125;, //函数去抖 即使在指定间隔内调用多次但是只执行一次 debounce:function (fn, threshhold, scope) &#123; threshhold || (threshhold = 32);//250ms是指定执行间隔 var last, deferTimer; return function () &#123; var context = scope || this; var now = +new Date, args = arguments; if (last &amp;&amp; now &lt; last + threshhold) &#123; // hold on to it clearTimeout(deferTimer); deferTimer = setTimeout(function () &#123; last = now;//过了threshhold才会将该函数插入js进程队列，至少此后才会执行这一句 fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;; &#125;, //显示 tooltip的函数 tipshow:function(position,ctx)&#123; var canPos=this.getCanActPos(this.canvas); var rPos=&#123;&#125;; rPos.x=position.x-canPos.x-this.center.x; rPos.y=position.y-canPos.y-this.center.y; rPos.dis=Math.floor(Math.sqrt(rPos.x*rPos.x+rPos.y*rPos.y)); if(rPos.dis&lt;this.radius)&#123; rPos.arc= Math.atan2(rPos.y,rPos.x); if(rPos.arc&lt;=0)&#123; rPos.arc+=Math.PI*2; &#125; var sum=this.series.reduce(function(pre,cur)&#123; return pre+cur; &#125;); var percent=this.series.map(function(item)&#123; return item/sum; &#125;); var perArc=percent.map(function(item)&#123; return item*Math.PI*2; &#125;); var curArc=0;var curIndex=0; var len=this.series.length; for(var i=0;i&lt;len;i++)&#123; curArc+=perArc[i]; if(rPos.arc&lt;curArc)&#123; curIndex=i; break; &#125; &#125; if(this.tip.canvas===null)&#123; this.tip.canvas=document.createElement('canvas'); this.tip.canvas.id="tip"; document.body.appendChild(this.tip.canvas); this.tip.canvas.style.position="absolute"; this.tip.canvas.style.left=position.x+20+"px"; this.tip.canvas.style.top=position.y+20+"px"; this.tip.canvas.style.zIndex=2; this.tip.canvas.height=50; this.tip.canvas.width=100; this.tip.ctx=this.tip.canvas.getContext("2d"); &#125; this.tip.canvas.style.display="block"; var tctx=this.tip.ctx; tctx.clearRect(0,0,this.tip.canvas.width,this.tip.canvas.height); this.tip.canvas.style.left=position.x+20+"px"; this.tip.canvas.style.top=position.y+20+"px"; tctx.fillStyle="rgba(200,200,200,0.6)"; tctx.fillRect(0, 0, this.tip.canvas.width,this.tip.canvas.height); tctx.fillStyle="#000"; tctx.font="15px bold Arail"; // tctx.textBaseLine="top"; tctx.fillText((percent[curIndex]*100).toFixed(2)+"%", 20, 40); tctx.fillText(this.legend[curIndex], 20, 20); &#125;else if(this.tip.canvas!=null)&#123; this.tip.canvas.style.display="none"; &#125; &#125;, //饼图的绘制函数 render:function()&#123; var center=&#123; x:Math.floor(this.width/2), y:Math.floor(this.height/2) &#125;; this.center=center; var edge=50; var ctx=this.canvas.getContext("2d"); var radius=Math.min(center.x,center.y)-edge*2; this.radius=radius; var sum=this.series.reduce(function(pre,cur)&#123; return pre+cur; &#125;); var percent=this.series.map(function(item)&#123; return item/sum; &#125;); var perArc=percent.map(function(item)&#123; return item*Math.PI*2; &#125;); var curArc=0; var len=this.series.length; ctx.save(); ctx.strokeStyle="#000"; //drawpie for (var i=0;i&lt;len;i++)&#123; ctx.beginPath(); ctx.arc(center.x,center.y,radius,curArc,curArc+perArc[i]); ctx.lineTo(center.x,center.y); ctx.closePath(); ctx.fillStyle=this.colors[i]; ctx.fill(); curArc=curArc+perArc[i]; &#125;; //legend ctx.font="15px bold Arail"; // ctx.textBaseLine="bottom"; for(var i=0;i&lt;len;i++)&#123; ctx.fillStyle=this.colors[i]; ctx.fillRect(this.width-2*edge+5, 20*i, 15, 15); ctx.fillStyle="#000"; ctx.fillText(this.legend[i], this.width-2*edge+25, 20*i+15); &#125; //title ctx.textAlign="center"; ctx.fillText(this.title,center.x,edge-20); //tooltip if(this.tip.enable)&#123; var mousePos=&#123;x:0,y:0&#125;; this.canvas.addEventListener("mousemove", pie.debounce(function(e)&#123; // e = e || window.event; // mousePos.x = e.clientX; // mousePos.y = e.clientY; mousePos=pie.getMousePos(e); pie.tipshow.apply(pie,[mousePos,ctx]); &#125;, false)); &#125; &#125;, //获取canvas的绝对坐标 getCanActPos:function(element)&#123; var actualLeft = element.offsetLeft; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; actualTop += current.offsetTop; current = current.offsetParent; &#125; return &#123;x:actualLeft,y:actualTop&#125;; &#125;&#125;; var canvas = document.getElementById("cas"); // var ctx = canvas.getContext("2d"); var data = [10,20,50,100,30,40,70,22]; var legend=["C++","Ruby","Java","JS","Python","R","C","D"]; var colors=["#CCFFFF",'#99CC66','#CCCCFF','#0099CC',"#FF6600",'#996699','#FFFF00',"#FF6666"] var config={ canvas:canvas, series:data, title:"Coding language", legend:legend, tip:{enable:true}, colors:colors } //调用pie的初始化函数 pie.init(config); //绘制饼图 pie.render();]]></content>
      <tags>
        <tag>canvas</tag>
        <tag>chart</tag>
        <tag>pie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-blog]]></title>
    <url>%2F2018%2F11%2F05%2Fhexo-blog%2F</url>
    <content type="text"><![CDATA[起因原本旧的blog是16年开始学习前端的时候搭建的，纯html，css，js写的静态页面，当时这样选择是想多给自己一些手写基础代码的机会来逐渐熟悉前端基础。时过进迁，目前写blog的需求已经回归到写作本身了，这样旧的blog页带来的写作成本，导致我经常性在印象笔记、有道云笔记甚至本地markdown编辑器来码字，并且积攒在本地，难以及时更新到git。综上所述，旧的blog不再适合当前的场景，因此决定迁移为hexo方式。 hexo这部分，没什么难的，hexo官方文档非常简单明了，清晰易懂。 配置文章的静态资源路径为独立的，在主题设置中设置好post_asset_folder: true next 主题这个也是按照next官方文档一套走起，可以根据自己的需求，对主题定制。1git clone https://github.com/iissnan/hexo-theme-next themes/next 增加about，tags路由，123hexo new page &quot;about&quot;hexo new page &quot;tags readMore在文章中想要截断的位置手动增加1&lt;!-- more --&gt; 旧的已有blog页面迁移canvas pie涉及到如何在hexo中写html、js TODO issue的文字迁移 本地markdown迁移 其他云存储的笔记迁移]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
